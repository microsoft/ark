#include "gpu/gpu_loop_kernel.h"

#include <sstream>

#include "env.h"
#include "file_io.h"
#include "gpu/gpu.h"
#include "gpu/gpu_event.h"
#include "gpu/gpu_logging.h"

#define MAX_LOOP_COUNTER 10000000

#if defined(ARK_CUDA)
#include <cuda/atomic>
static int atomicLoadRelaxed(int* ptr) {
    return cuda::atomic_ref<int, cuda::thread_scope_system>{*ptr}.load(
        cuda::memory_order_relaxed);
}
static void atomicStoreRelaxed(int* ptr, int val) {
    cuda::atomic_ref<int, cuda::thread_scope_system>{*ptr}.store(
        val, cuda::memory_order_relaxed);
}
#elif defined(ARK_ROCM)
static int atomicLoadRelaxed(int* ptr) {
    return __atomic_load_n(ptr, __ATOMIC_RELAXED);
}
static void atomicStoreRelaxed(int* ptr, int val) {
    __atomic_store_n(ptr, val, __ATOMIC_RELAXED);
}
#endif  // defined(ARK_ROCM)

namespace ark {

GpuLoopKernelV2::GpuLoopKernelV2(std::shared_ptr<GpuManager> manager,
                                 const std::string& name,
                                 const std::vector<std::string>& codes_body,
                                 int num_sm, int num_warp,
                                 unsigned int smem_bytes)
    : GpuKernelV2(manager, {},
                  {num_warp * manager->info().threads_per_warp, 1, 1},
                  {num_sm, 1, 1}, (smem_bytes < 4) ? 4 : smem_bytes, name,
                  {{nullptr, sizeof(GpuPtr)}}),
      manager_(manager),
      timer_begin_(manager->create_event()),
      timer_end_(manager->create_event()) {
    this->flag_ = manager->malloc_host(
        sizeof(int), gpuHostAllocMapped | gpuHostAllocWriteCombined);
    *(int**)this->params_ptr_[0] = (int*)this->flag_->ref<int>();

    auto& code_path = get_env().enforce_kernel_code_path;
    if (!code_path.empty()) {
        LOG(INFO, "Enforce kernel code path: ", code_path);
        this->codes_ = std::move(read_file(code_path));
    } else if (codes_body.size() > 0) {
        const std::string* ark_loop_body_code = nullptr;
        for (auto& code : codes_body) {
            if (code.find("ark_loop_body") != std::string::npos) {
                ark_loop_body_code = &code;
                break;
            }
        }
        assert(ark_loop_body_code != nullptr);

        std::stringstream ss;
        // clang-format off
    ss <<
    "// THIS KERNEL IS MACHINE-GENERATED BY ARK.\n"
    "#define ARK_THREADS_PER_BLOCK " << this->block_dim_[0] << "\n"
    "__device__ int _ITER = 0;\n"
    "#include \"ark_kernels.h\"\n"
    "__device__ ark::sync::State " ARK_LSS_NAME ";\n"
    "__device__ char *" ARK_BUF_NAME ";\n"
    << *ark_loop_body_code <<
    "extern \"C\" __global__ __launch_bounds__(" << this->block_dim_[0] << ", 1)\n" "void " << kernel_name_ << "(int *_it)\n"
    "{\n"
    "  int *shared_mem = (int *)_ARK_SMEM;\n"
    "  for (int i = threadIdx.x; i < ARK_SMEM_RESERVED_BYTES / sizeof(int); i += blockDim.x) {\n" "    shared_mem[i] = 0;\n" "  }\n"
    "  for (;;) {\n"
    "    if (threadIdx.x == 0 && blockIdx.x == 0) {\n"
    "      int iter;\n"
    "      while ((iter = ark::atomicLoadRelaxed(_it)) == 0) {}\n"
    "      _ITER = iter;\n"
    "    }\n"
    "    ark::sync_gpu<" << num_sm << ">(" ARK_LSS_NAME ");\n"
    "    if (_ITER < 0) {\n"
    "      return;\n"
    "    }\n"
    "    for (int _i = 0; _i < _ITER; ++_i) {\n"
    "      ark_loop_body(_i);\n"
    "      ark::sync_gpu<" << num_sm << ">(" ARK_LSS_NAME ");\n"
    "    }\n"
    "    if (threadIdx.x == 0 && blockIdx.x == 0) {\n"
    "      ark::atomicStoreRelaxed(_it, 0);\n"
    "    }\n"
    "    ark::sync_gpu<" << num_sm << ">(" ARK_LSS_NAME ");\n"
    "  }\n"
    "}\n";
        // clang-format on
        this->codes_ = std::move(ss.str());
    }
}

// void GpuLoopKernel::load() {
//     if (this->ctx->set_current() != gpuSuccess) {
//         ERR(ExecutorError, "Failed to set the context.");
//     }
//     //
//     if (!this->is_compiled()) {
//         ERR(InvalidUsageError, "Need to compile first before
//         initialization.");
//     }
//     if (this->stream != nullptr) {
//         // Wait until previous works finish.
//         this->wait();
//         return;
//     }
//     // Initialize global variables in the loop kernel.
//     GpuPtr buf_ptr_val = this->ctx->get_data_ref();
//     GpuPtr lss_ptr_addr;
//     GpuPtr buf_ptr_addr;
//     size_t tmp = 0;
//     GLOG(gpuModuleGetGlobal(&lss_ptr_addr, &tmp, this->module,
//     ARK_LSS_NAME)); GLOG(gpuModuleGetGlobal(&buf_ptr_addr, &tmp,
//     this->module, ARK_BUF_NAME)); std::array<int, 4> data = {0, 0, 0, 0};
//     GLOG(gpuMemcpyHtoD(lss_ptr_addr, data.data(), sizeof(int) *
//     data.size())); GLOG(gpuMemcpyHtoD(buf_ptr_addr, &buf_ptr_val,
//     sizeof(GpuPtr)));
//     // TODO: remove this hack
//     GpuPtr lss_0_ptr_addr;
//     GpuPtr lss_1_ptr_addr;
//     gpuError ret = gpuModuleGetGlobal(&lss_0_ptr_addr, &tmp,
//     this->module,
//                                       ARK_LSS_NAME "_0");
//     if (ret == gpuSuccess) {
//         GLOG(gpuMemcpyHtoD(lss_0_ptr_addr, data.data(),
//                            sizeof(int) * data.size()));
//     } else if (ret != gpuErrorNotFound) {
//         GLOG(ret);
//     }
//     ret = gpuModuleGetGlobal(&lss_1_ptr_addr, &tmp, this->module,
//                              ARK_LSS_NAME "_1");
//     if (ret == gpuSuccess) {
//         GLOG(gpuMemcpyHtoD(lss_1_ptr_addr, data.data(),
//                            sizeof(int) * data.size()));
//     } else if (ret != gpuErrorNotFound) {
//         GLOG(ret);
//     }
//     // set the data buffer pointers of remote gpus
//     int nrph = get_env().num_ranks_per_host;
//     int nodes_id = this->ctx->get_gpu_id() / nrph;
//     // only set the GPU remote data buf pointers of the GPUs on the same
//     node for (int i = nodes_id * nrph;
//          i < (nodes_id + 1) * nrph && i < this->ctx->get_world_size();
//          i++) {
//         GpuPtr data_buf_value = this->ctx->get_data_ref(i);
//         if (data_buf_value == 0) {
//             continue;
//         }
//         GpuPtr data_buf_ptr;
//         string data_buf_name = ARK_BUF_NAME + std::to_string(i);
//         gpuError _e = gpuModuleGetGlobal(&data_buf_ptr, &tmp,
//         this->module,
//                                          data_buf_name.c_str());
//         if (_e == gpuErrorNotFound) {
//             LOG(DEBUG, "global variable ", data_buf_name, " not found");
//             continue;
//         }
//         LOG(DEBUG, data_buf_name, " data_buf_ptr=", std::hex,
//         data_buf_ptr,
//             " data_buf_value=", data_buf_value);
//         GLOG(gpuMemcpyHtoD(data_buf_ptr, &data_buf_value,
//         sizeof(GpuPtr)));
//     }
//     GpuCommSw *comm = this->ctx->get_comm_sw();
//     if (comm->get_proxy_channels_num() > 0) {
//         GpuPtr channel_addr;
//         GLOG(gpuModuleGetGlobal(&channel_addr, &tmp, this->module,
//                                 "_ARK_PROXY_CHANS"));
//         const void *chans_ref = comm->get_proxy_channels_ref();
//         size_t chans_bytes = comm->get_proxy_channels_bytes();
//         GLOG(gpuMemcpyHtoD(channel_addr, const_cast<void *>(chans_ref),
//                            chans_bytes));
//     }
//     if (comm->get_sm_channels_num() > 0) {
//         GpuPtr channel_addr;
//         GLOG(gpuModuleGetGlobal(&channel_addr, &tmp, this->module,
//                                 "_ARK_SM_CHANS"));
//         const void *chans_ref = comm->get_sm_channels_ref();
//         size_t chans_bytes = comm->get_sm_channels_bytes();
//         GLOG(gpuMemcpyHtoD(channel_addr, const_cast<void *>(chans_ref),
//                            chans_bytes));
//     }
// }

// GpuState GpuLoopKernel::launch(gpuStream stream, bool disable_timing) {
//     this->elapsed_msec = -1;
//     if (!this->is_compiled()) {
//         ERR(InvalidUsageError, "Need to compile first before
//         initialization.");
//     } else if (stream == nullptr) {
//         ERR(InvalidUsageError, "Given an invalid stream.");
//     } else if (this->stream != nullptr) {
//         if (this->stream == stream) {
//             LOG(WARN, "Ignore launching twice.");
//             return gpuSuccess;
//         } else {
//             ERR(InvalidUsageError, "This loop kernel is already
//             running.");
//         }
//     }
//     if (!disable_timing) {
//         GLOG(gpuEventRecord(this->timer_begin, stream));
//     }

//     this->ctx->get_comm_sw()->launch_request_loop();

//     // Initialize loop flags.
//     atomicStoreRelaxed(this->flag, 0);
//     GpuState res = GpuKernel::launch(stream);
//     if (res == gpuSuccess) {
//         this->stream = stream;
//         if (!disable_timing) {
//             GLOG(gpuEventRecord(this->timer_end, stream));
//             this->is_recording = true;
//         }
//     }
//     return res;
// }

void GpuLoopKernelV2::run(int iter) {
    if (iter > 0) {
        while (atomicLoadRelaxed(this->flag_->ref<int>()) > 0) {
        }
        atomicStoreRelaxed(this->flag_->ref<int>(), iter);
    }
}

// bool GpuLoopKernel::poll() { return atomicLoadRelaxed(this->flag) <= 0; }

// void GpuLoopKernel::wait() {
//     int cnt = MAX_LOOP_COUNTER;
//     while (atomicLoadRelaxed(this->flag) > 0) {
//         if (--cnt > 0) {
//             continue;
//         }
//         // Check if the kernel encountered an error.
//         gpuError res = gpuStreamQuery(this->stream);
//         if (res == gpuSuccess) {
//             if (atomicLoadRelaxed(this->flag) > 0) {
//                 LOG(WARN, "Stream is finished but the loop flag is still
//                 set."); break;
//             } else {
//                 LOG(WARN,
//                     "wait() is delayed by a stream query. Regarding "
//                     "timing measurements may be inaccurate.");
//                 break;
//             }
//         } else if (res == gpuErrorNotReady) {
//             cnt = MAX_LOOP_COUNTER;
//         } else {
//             GLOG(res);
//         }
//     }
// }

// void GpuLoopKernel::stop() {
//     this->wait();
//     atomicStoreRelaxed(this->flag, -1);
//     GLOG(gpuStreamSynchronize(this->stream));
//     if (is_recording) {
//         GLOG(gpuEventElapsedTime(&(this->elapsed_msec),
//         this->timer_begin,
//                                  this->timer_end));
//         this->is_recording = false;
//     }
//     this->stream = nullptr;
//     this->ctx->get_comm_sw()->stop_request_loop();
// }

}  // namespace ark
